# 操作系统――实验三
--------------------------------------------------------------

### 练习1：给未被映射的地址映射上物理页
------------------------------------------


首先，我们考虑此练习针对哪种异常情形。

`do_pgfault()`函数是**页访问异常**的中断处理例程。产生页访问异常的原因有以下三种：

- **A  目标页帧不存在**（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销）；

- **B  相应的物理页帧不在内存中**（页表项非空，但Present标志位=0，比如在swap分区或磁盘

  文件上）；

- **C  不满足访问权限**（此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或

  者有程序试图写只读页面）

练习1 当**目标页帧不存在**时的情况。

接下来分析`do_pgfault()`函数的结构。

可以看出，在练习1的代码之前的几个`goto failed;`语句，已经对**情形C**进行了处理。故接下来的代码将要处理**情形A**和**情形B**。两种情形区分的关键在于：**相应页表项（pte）是否存在**，存在则为**情形B**，不存在则为**情形A**。

故先用`get_pte()`函数得到页表项`*ptep`，若其为0（**情形A**），则使用`pgdir_alloc_page()`函数为其分配一个新物理页，并建立虚拟地址到此物理页的映射。事实上，由于较好的封装，只需两行代码即可完成。


【问题1.1】请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。

- 页目录项（一级页表项）存储了所有二级页表（PT）页的线性基地址+标记信息，页表项（二级页表项）存储了la对应的物理页的基地址+标记信息（lab2中主要用到了最低的三个标记位）。二者基本上可以等同，其低12位的标记信息如下（见mmu.h）：

```C
#define PTE_P           0x001                   // Present 对应物理页面是否存在
#define PTE_W           0x002                   // Writeable 对应物理页面是否可写
#define PTE_U           0x004                   // User 对应物理页面用户态是否可以访问
#define PTE_PWT         0x008                   // Write-Through 对应物理页面在写入时是否写透(即向更低级储存设备写入)
#define PTE_PCD         0x010                   // Cache-Disable 对应物理页面是否能被放入高速缓存
#define PTE_A           0x020                   // Accessed 对应物理页面是否被访问
#define PTE_D           0x040                   // Dirty 对应物理页面是否被写入
#define PTE_PS          0x080                   // Page Size 对应物理页面的页面大小
#define PTE_MBZ         0x180                   // Bits must be zero 必须为零的部分
#define PTE_AVAIL       0xE00                   // Available for software use 用户可自定义的部分
```

- 替换算法中，PTE_P位为0时，页表项变为了swap_entry，用来描述一个被置换出去的物理页，维护该物理页与 swap 磁盘上扇区的映射关系。其他flag位可以用于标记该物理页的更多信息，方便ucore在中断/异常处理时判断要处理的具体情形。

【问题1.2】如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

- 产生页访问异常后，CPU会把引起页访问异常的线性地址装入到寄存器CR2中，并给出错误码errorCode，以说明页访问异常的类型。（ucore OS则负责将errCode存在内核态的栈中，并根据中断向量表访问并执行相应的中断服务例程。）




###练习2：补充完成基于FIFO的页面替换算法
-------------------------------------------------------


练习2对应上述的**情形B**。此时页表项`*ptep`不为0，它代表一个swap_entry。此时该页表项对应的物理页帧page处于被换出的状态，欲处理这个缺页异常，就要将它换入。因此在`do_pgfault()`中，应完成整个换入过程，步骤如下：

- 首先调用`swap_in()`函数，将page换入。
- 换入后，调用`page_insert()`函数，重写页表项`*ptep`，也即建立虚拟地址addr与物理页帧page间的映射。
- 接下来为页替换算法做一些标记。

```C
swap_map_swappable(mm, addr, page, 1); 
page->pra_vaddr = addr; //used when being swaped out
```

- - 这里首先调用统一接口`swap_map_swappable()`维护可替换的物理页序列，即将新换入的物理页放到页替换算法的“替换序列”中，方便之后按顺序换出。
  - 其次是标记此物理页对应的虚拟地址。我的实现漏掉了这一句，后来发现在swap.c的`swap_out()`函数中会用到被换出页的`pra_vaddr`，用以查找并修改换出页对应的页表项`*ptep`。

**再看针对FIFO算法的具体实现**：swap_fifo.c。

这里采用了类似面向对象抽象类的思路，swap_fifo.c中的swap_manager_fifo是对swap_manager的一个具体实现，类似于对抽象父类的继承。

练习2主要实现`_fifo_map_swappable()`和`_fifo_swap_out_victim()`两个函数。

这里要维护的可替换物理序列即为双向链表`pra_list_head`，每一个物理页对应的表项为`struct Page`的`pra_page_link`元素。值得注意的是，这里的`pra_list_head`并不是FIFO队列的队头，而是一个永远不动的标杆，`list_prev(pra_list_head)`为真正的队头，而插入其后的表项则为队尾。

故对于最简单的FIFO替换算法，在`_fifo_map_swappable()`中只需每次将新换入的物理页插入队尾，而在`_fifo_swap_out_victim()`中只需取出真正的队头，得到其物理页，再从链表中删除这个队头。不在话下。

【extended clock页替换算法】

这里默认extended clock页替换算法（下简称**EC**）即原理课上讲的**改进的时钟算法**。

现有的swap_manager框架**已经足以支持**在ucore中实现此算法。

**设计方案：**

- 与FIFO算法相同，EC算法也会维护一个按照**换入先后顺序**排序的双向队列，这一点可由练习2做到。
- 与FIFO不同的是，每当内存中的物理页帧page被访问或修改时，需要实时地将对应页表项`*ptep`的**访问位`P_A`和修改位（脏页标记）`P_D`置1**。（对应页表项可以由`get_pte()`得到，虚拟地址参数为`page->pra_vaddr` 。）
- 这样之后，在选择被换出页时（`_ec_swap_out_victim()`函数），就要按照时钟算法的思路，从队头开始循环扫描整个可替换队列，并对标记位作如下变换：

| 原标记位（访问位:修改位） | 新标记位    |
| ------------- | ------- |
| 00            | （命中，换出） |
| 01            | 00      |
| 10            | 00      |
| 11            | 01      |

- 找到第一个标记为00的页，即为换出页。

【问题2.1】需要被换出的页的特征是什么？

- 被换入的时间较早，
- 最近未被使用（访问），
- 且未被修改的页（非脏页），最容易被换出。

【问题2.2】在ucore中如何判断具有这样特征的页？

第一个特征是通过在换入页时维护的**可替换物理页链表**来判断，越靠近队头的被换入时间越早。

后两个特征是通过**物理页对应的页表项**的**标记位**来判断，`P_A`为1说明被访问过，`P_D`为1说明被修改过。

【问题2.3】何时进行换入和换出操作？

- 换入：在出现缺页异常时，若为**情形B**，即相应的物理页帧不在内存中，则调用`swap_in()`进行换入操作。
- 换出：在使用`alloc_pages()`为虚拟地址分配物理内存时，若内存已满，则调用`swap_out()`进行换出操作。



